规范化where的过程：
1. 定义分隔符列表，分隔符包括 空格,'"()[]<>=+-×/
2. 根据分隔符分离出操作数与操作符
3. 操作数包括常量（字符串常量、数字常量、或者日期）、参数(?)与变量(没有被'或"包围，并且以字符开头的单词）
4. 只有变量需要规范化
5. 如果变量中没有.，则变量应该为字段名或属性名（规范化的方式为得到字段名或属性名对应的对象名称，然后替换为字段名）
6. 如果变量中包含。，则.前面的是关联表名或者与关联表对应的属性名，需要将其替换为表名，并且需要在from中增加对表的join
7. 如果where中包括子查询，则子查询的表明不能与主查询的表名/关联表名或者对应的属性名相同，否则无法区分，此时必须起别名

级联更新
级联插入
级联删除
//多对多关联需要生成insert中间表的SQL，并且中间表没有对应的类型，只能生成原生的SQL

关联对象的更新问题：
1. 中间表的关联操作需要直接生成SQL语句，因为没有对应的类型
2. 中间表的关联操作可能与主表的操作不一致。例如主表增加一个对象，关联一个已经存在的关联对象。关联对象很可能无需更新或者只需要update，此时不需要insert关联对象

需要1个Save函数，在Save内部根据对象状态判断是insert还是update(根据对象是否在一级缓存中存在来判断）


插入对象：
1. 初始化SQL列表
1. 生成对象对应的单表插入的SQL，增加到SQL列表
2. 循环关联属性，
  2.1. 如果发现有级联插入或级联保存的，根据属性值（列表或者单个对象）生成级联的插入SQL，并且放在主对象插入的SQL之前，增加到SQL列表
  2.2. 继续判断关联属性是否有级联的子属性，如果有，继续2.1（此处可采用广度优先搜索，这样可以把相同表的INSERT放到一起，有利于后面的批处理优化。搜索子对象要考虑环的问题）
3. 执行SQL列表
4. 读取插入后数据库更新的自增字段（如果是SQL列表，如何得到每个SQL对应的对象更新自增值?）
5. 如果有时间戳字段，更新对象的时间戳（用SQL列表，如何得到每个SQL对应的对象的时间戳？(要保留每条SQL对应的对象吗？)用gorouter异步执行？这样可以提高效率。但异步更新的并发问题如何处理？）

更新对象：
1. 初始化SQL列表
1. 生成对象对应的单表update的SQL，增加到SQL列表
2. 循环关联属性，
  2.1. 如果发现有级联update或级联保存的，根据属性值（列表或者单个对象）生成级联的SQL（如果是列表，要判断哪些修改了，哪些是增加的，哪些被移除了），并且放在主对象插入的SQL之前，增加到SQL列表
  2.2. 继续判断关联属性是否有级联的子属性，如果有，继续2.1（此处可采用广度优先搜索，这样可以把相同表的INSERT放到一起，有利于后面的批处理优化。搜索子对象要考虑环的问题）
3. 执行SQL列表
5. 如果有时间戳字段，更新对象的时间戳（用SQL列表，如何得到每个SQL对应的对象的时间戳？(要保留每条SQL对应的对象吗？)用gorouter异步执行？这样可以提高效率。但异步更新的并发问题如何处理？）

如何判断对象是否被修改？用HASH来判断可能比较快，保存原始的hash值，与现在的比较
如何判断对象列表是否有删除的对象？可能要保持列表原始的ID列表
另外一个对象自己的属性没有修改，不代表关联对象没有被修改，仍然需要判断
