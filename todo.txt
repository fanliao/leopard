规范化where的过程：
1. 定义分隔符列表，分隔符包括 空格,'"()[]<>=+-×/%。 mysql的保留字包括select, from, where, left, right, outer, join, order by, group by, having, limit, between, add ,or, is, in, null, distinct, exists, like
2. 根据分隔符分离出操作数与操作符
3. 操作数包括常量（字符串常量、数字常量、或者日期）、参数(?)与变量(没有被'或"包围，并且以字符开头的单词）
4. 只有变量需要规范化
5. 如果变量中没有.，则变量应该为字段名或属性名（规范化的方式为得到字段名或属性名对应的对象名称，然后替换为字段名）
6. 如果变量中包含。，则.前面的是关联表名或者与关联表对应的属性名，需要将其替换为表名，并且需要在from中增加对表的join
7. 如果where中包括子查询，则子查询的表明不能与主查询的表名/关联表名或者对应的属性名相同，否则无法区分，此时必须起别名

级联更新
级联插入
级联删除
//多对多关联需要生成insert中间表的SQL，并且中间表没有对应的类型，只能生成原生的SQL

关联对象的更新问题：
1. 中间表的关联操作需要直接生成SQL语句，因为没有对应的类型
2. 中间表的关联操作可能与主表的操作不一致。例如主表增加一个对象，关联一个已经存在的关联对象。关联对象很可能无需更新或者只需要update，此时不需要insert关联对象

需要1个Save函数，在Save内部根据对象状态判断是insert还是update(根据对象是否在一级缓存中存在来判断）


插入对象：
1. 初始化SQL列表
1. 生成对象对应的单表插入的SQL，增加到SQL列表
2. 循环关联属性，
  2.1. 如果发现有级联插入或级联保存的，根据属性值（列表或者单个对象）生成级联的插入SQL，并且放在上级对象插入的SQL之后，增加到SQL列表
  2.2. 继续判断关联属性是否有级联的子属性，如果有，继续2.1（此处可采用广度优先搜索，这样可以把相同表的INSERT放到一起，有利于后面的批处理优化。搜索子对象要考虑环的问题）
3. 执行SQL列表
4. 读取插入后数据库更新的自增字段（如果是SQL列表，如何得到每个SQL对应的对象更新自增值?）如果主键是自增字段，就无法批量插入，否则可以考虑批量插入
5. 插入完成后更新对象到缓存
6. 如果有时间戳字段，更新对象的时间戳（用SQL列表，如何得到每个SQL对应的对象的时间戳？(要保留每条SQL对应的对象吗？)用gorouter异步执行？这样可以提高效率。但异步更新的并发问题如何处理？）
  有2种方法：
  1. 全部插入完成后，使用in查询所有插入记录的时间戳更新对象属性（要测试in的效率）
  2. 每条插入后查询数据库(要比较in与多条查询的效率)
7. 插入对象可以选择是否无需返回，如果是的话，可以无需读取自增和时间戳，但对象不会增加到缓存

更新对象：
1. 初始化SQL列表
1. 生成对象对应的单表update的SQL，增加到SQL列表
2. 循环关联属性，
  2.1. 如果发现有级联update或级联保存的，根据属性值（列表或者单个对象）生成级联的SQL（如果是列表，要判断哪些修改了，哪些是增加的，哪些被移除了），并且放在主对象插入的SQL之前，增加到SQL列表
  2.2. 继续判断关联属性是否有级联的子属性，如果有，继续2.1（此处可采用广度优先搜索，这样可以把相同表的sql放到一起，有利于后面的批处理优化。搜索子对象要考虑环的问题）
3. 执行SQL列表
5. 如果有时间戳字段，更新对象的时间戳（用SQL列表，如何得到每个SQL对应的对象的时间戳？(要保留每条SQL对应的对象吗？)用gorouter异步执行？这样可以提高效率。但异步更新的并发问题如何处理？）

删除对象：
1. 初始化SQL列表
2. 生成对象对应的单表的delete sql，增加到SQL列表（如果是删除一个集合，可以采用in子句生成一条SQL即可）
3. 循环关联属性
  3.1. 如果发现有级联删除或级联保存的，每个关联属性都应该生成一条delete sql（为了提高效率，要采用子查询一次删除），并且放在上级对象插入的SQL之前，增加到SQL列表
  3.2.继续判断关联对象是否还有级联删除的关联对象，如果有，继续3.1处理（子查询条件要修改）

如何利用子查询一次删除关联记录：

a {
 aid
}

b {
 bid
 aid
}

c {
 cid
 bid
}




问题：
如何判断对象是否被修改？用HASH来判断可能比较快，保存原始的hash值，与现在的比较(可以在一级缓存中保持对象原始的hash值）
如何判断对象列表是否有删除的对象？可能要保持列表原始的ID列表（每次得到一个列表，需要在一级缓存中记录列表中原始ID的列表）
另外一个对象自己的属性没有修改，不代表关联对象没有被修改，仍然需要判断
